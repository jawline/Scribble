<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js">
	<!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>Scribble programming language.</title>
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

		<link rel="stylesheet" href="css/normalize.css">
		<link rel="stylesheet" href="css/main.css">
		<script src="js/vendor/modernizr-2.6.2.min.js"></script>

		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
		<script>
			window.jQuery || document.write('<script src="js/vendor/jquery-1.10.2.min.js"><\/script>')
		</script>
		<script src="js/plugins.js"></script>
		<script src="js/main.js"></script>

	</head>
	<body>
		<!--[if lt IE 7]>
		<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
		<![endif]-->

		<div class="panel">
			<h1 class="panel-header">Scribble - Design and roadmap</h1>

			<div class="panel-content">

				<p>
					This third year project will be about producing a small programming language and virtual machine in C++.

					<p>
					Scribble is a embeddable programming language designed to be used as a low cost solution (In terms of space and price and time) to anybody trying to extend the functionality or reduce the complexity of their application. It will allow a developer to interact with user generated content via a two way API, functions declared in Scribble can be executed from C++ and functions declared in C++ can be allowed to execute in Scribble. It has been designed to simplify a development process; It does this by allowing developers to offload less intensive or important code into a easier garbage collected language whilst maintaining a strict environment with clear types and promoting a clean codebase.</p>
					
</p>

			</div>
		</div>

		<div class="panel">
			
			<h1 class="panel-header">The Prototype</h1>

			<div class="panel-content">

				<p>
					Work started on a prototype of the language to prove to myself ahead of time that I had the technical skills to achieve what I wanted after a dialog with my supervisor toward the end of my second year.<br/><br/> This has led to me laying out a three part design which includes the parser which takes the Scribble code and converts it into a set of functions and types and generates intermediate code for the Virtual Machine. An intermediate Parser named SASM which will take code in the form of an intermediate assembly style language generated by the first parser and a Virtual Machine which will run bytecode generated by the SASM parser.<br/><br/>This prototype has clearly highlighted the portions of the application that I am likely to struggle most with are ensuring a conflict free grammar, memory handling and code generation which should drastically improve my ability to budget time.

				</p>


				<p>
					The prototype used a similar tree generation parser to the one proposed in this project however the execution of the language was done on the tree. The grammar also caused issues as Bison could not generate a parser without potential conflicts for it. However the basic syntax of the language and the structure of the tree is likely to remain which will allow me to reuse large portions of code in the construction of the new one.

				</p>

				<p>I also prototyped a simple virtual machines similar to LUA's VM design however with significantly reduced functionality. This will allow me to save time when designing the new virtual machine by providing me with existing experience and a codebase to draw from.</p>

				<p>These prototypes should help me achieve my initial ambitious timescales. However neither of them included any kind of formalization which will be the focus of my efforts when developing the full project.</p>

			</div>
		</div>

		<div class="panel">
			<h1 class="panel-header">Technical background ( Abstract )</h1>

			<div class="panel-content">
				<h2 class="heading">Scribble</h2> <h3 class="subheading"> The language</h3>
				<p>
				The language will be split into at least three possibly four seperate sections during development. The grammar which Bison & Flex will use to generate the parser and which will define how the language is written will be one section. The glue which handles the actual grabbing of the files and handing each of them over to bison will be another and finally a tree like structure that will be generated by Bison will handle both intermediate code generation and code verification ( Checking that code that has a valid syntax isn't incorrect in some other way such as type abuse ).

				<br/><br/>The grammar will be the key part of the language in the design phases, as how the language is to use is in the end the most important part of the project however it is not likely to be the most time consuming as constructing testing and verifying that each part of the tree works is likely to be an extremely large amount of work.

				<br/><br/>There will also be a large amount of testing and refining required during this period as it's hard to guage how well an idea will work until it is put into practice. While this would be hard to budget time for due to its unpredictable nature it is likely to be a large portion of the time spent working on the language.

				<br/><br/>The language itself will be strict language where everything has a predefined type. Due to the ambitousness of the project to save time as much of the grammar and tree structure that can be reused from the prototype will be. It will take ideas from languages such as GoLang and LUA. and its syntax will resembal a C style syntax with a few exceptions such as type being declared to the right of a variable or function such as var Number : int; or func F() : bool { }. There are several different ideas and aproachs I wish to trial and though I fully expect most of them to be pointless in practice the only real way I will have of finding out if an idea works is to implement it and see if it is useful. My final aim deliverable for the language is to have a language with a clean syntax that lends itself to obvious understable code whilst remaining concise and a parser that is quick ( enough ) and as bug free as possible with an emphasis on making sure there is no ambiguity in the syntax ( No two rules that conflict or could cause issues with the language ).
				</p>

			</div>

			<hr/>

			<div class="panel-content">
				<h2 class="heading">ScribbleASM</h2> <h3 class="subheading"> The intermediate language</h3>
				<p>
				The intermediate language is used as a stepping stone between the complex high level Scribble parser and the low level bytecode that the Virtual Machine accepts. It will take human readable pseudo-assembly generated by the higher level parser and convert it down to bytecode. This step is mainly for debugging to allow me to have a look at a human readable version of the bytecode being generated.<br/><br/>The specification for this will be less formal as it is a much less important part of the project and this program may become obselete in the future as my expertese matures and I feel comfortable without a human readable version of the generated code sitting in the middle.<br/><br/>The instructions will usually follow the same format as their bytecode equivilent ( For example, the arguments will be in the same order in SASM that they would be expected to be encoded into the instruction ).
				</p>
			</div>

			<hr/>

			<div class="panel-content">
				<h2 class="heading">ScribbleVM</h2> <h3 class="subheading"> The virtual machine</h3>	
				<p>
					<p>The design of the virtual machine demands both a formal specification and an implementation. Though they will probably be developed in unisen they should be entirely seperate entitys. The specification documenting the expected behaviour of every type of instruction while the virtual machine will contain my own implementation of the specification.<br/><br/>It will be a register based virtual machine with 64 bit instructions. This is to allow myself the largest window for expansion given that memory constraints and space constraints are unlikely to be a problem with any of the processors and systems available today.</p>
					<p>The formal specification is required as without a specification the virtual machine would be too inconsistent and ambiguous any potential client would see the platform as risky. It will include a description of the bytecode that the virtual machine is capable of handling as well as a broader description of how things like memory should be handled ( So, for example the specifics of the garbage collector or reference counter can be left to the implementation but the specification should make clear that memory shouldn't need to be freed manually by the developer ). It should also be clear enough to allow any third party to implement their own virtual machine capable of executing the same bytecode. </p> <p>The implementation on the other hand will be a lot more fluid than the specification. This is the first virtual machine I have attempted to implement from the ground up capable of doing anything non trivial ( Having only looked at emulation of older devices in the past ) and thus I am bound to make plenty of mistakes or design choices which I later may decide to rip out or completely change. Likely areas for this are Garbage Collection vs Reference Counting. The project is also very large and having the formalized specification will help me deal with the scale better during implementation as I will be much more capable of identifying crucial and less crucial parts of the program.</p>
				</p>
			</div>

		</div>

		<div class="panel">
			<h1 class="panel-header">Timeline</h1>

			<p>The work listed on this timeline will continue on from the prototype developed during the summer. It is because of this I have decided to work on the virtual machine first. By building upon the prototype I can spend time implementing a virtual machine specification at the start of the project and avoid the issues that would arise when attempting to design and formalizing a good syntax and a functional virtual machine at the same time.</p>

			<p>As each portion of this project is fairly reliant on the other portions ( with no Scribble it will be difficult to construct a virtual machine as there will be no code to execute, with no VM Scribble will be unable to execute code etcetera ) it is likely that often whilst working on a feature for one I will need to implement a feature for the other. This is anothe reason for tackling the lower level portions first however it may still be the case that often a feature for one leads to changes in all three portions of the program. </p>

			<p>During the development I will be constructing and updating a more short term roadmap containing lists of planned short term features ( such as implementing a new type ) per iteration within each of the broader sections defined here. It would be difficult to write this now as more in depth plans are bound to change when work has begun.</p>

			<hr/>

			<div class="panel-content">
			<h2 class="heading">Term One</h2> <h3 class="subheading"> Construction </h3>
			<hr/>

			<p>
				<h3 class="roadmap-item-heading">Tools</h3> - Over the summer I have been collecting and building a set of tools to make the development process easier. These tools include scripts to handle automatic build number incrementing and the Makefile will need to be cleaned up and refined ( In their current form they are littered with relics from failed experiments ). Some time will need to be spent cleaning and adapting this tools so that I do not have to worry about them later. These tools will become an integral part of the project, most are likely to be executed every single time the project is built and if one of them is faulty it could lead to some really cryptic debugging sessions. <b class="subheading"> The work will be completed by the end of the 2nd week of term.</b>
			</p>
			
			<hr/>

			<p>
			
				<h3 class="roadmap-item-heading">Virtual machine development</h3> - The virtual machine is one of three integral portions of the project. It will involve the development of a formal specification and an implementation.

				<p><b>Formal specification</b> - The formal specification for the virtual machine will be written in conjuction with the development of my implementation of it. Initially most of the work done will be regarding formal definitions of each possible OpCode within the VM. Making sure that they provide the functionality required and also making sure that I don't have too many. Later the specification will include provisions on how the memory should be handled and on how types should be defined and whether the VM will support higher level concepts like reflection of data structures ( Extracting type information during runtime with OpCodes). The last portion that will be added to the specification is the part defining how data types and functions will be registered so that they are identifiable by the virtual machine. This will be the last portion as this is one of the less important areas and also I have a few different ideas regarding possible approachs ( Automatic detection based on a path, everything registered beforehand, some kind of hybrid system which allows for native code to present itself in a form automatically executable by the virtual machine ).</p>

				<b class="subheading" style="margin-left: 0;" >The formal specification will be completed by the end of the first month however it will be updated as the requirements of the project change. </b>
			
				<p><b>VM Implementation</b> - My virtual machine will be designed using iterative model, initially supporting only base operations each next opcode being devised to suit a specific issue or need that I come accross when trying to make it compatable with the requirements Scribble the high level language it has to support. I have decided to take this approach so as to guage the real world usefulness and viability of proposed features of the formal specification.</p> 

				<b class="subheading" style="margin-left: 0;" > The implementation will begin development will begin with the design of the virtual machine. After the initial virtual machine specification is formalized the virtual machine implementation will be aggresively developed and maintained to keep it up to date with the specification. </b>

			</p>

			<p>

				<h3 class="roadmap-item-heading">Intermediate language development</h3> - The intermediate will be comprised of a bison & flex, a set of interfaces allowing a developer to easily convert intermediate code to bytecode and a formal set of clear documentation explaining the syntax of the assembly language and the result of each possible statement.

				<b class="subheading" style="margin-left: 0;" >Work will begin at the end of the first month. It will take one week to complete with one further week to formalize the specification and iron out any potential issues.</b>

			</p>

			<h3 class="roadmap-item-heading">Language development</h3> - Time allocation on the language will be split down into several subsections.
			<p>
				<p>
					<b>Grammar</b> - The grammar will likely be one of the first sections of the language finished. It will be used by Bison to construct a parser which will form the tree structure described in the design section. This is the area however that is most prone to issue ( Bison Reduce/Reduce conflicts ) and is also the most subjective ( What I think is a good idea may be horrible in practice ) <b class="subheading">One month for an initial formal specification. From then on any new features will be formalized in the specification before being prototyped in the grammar and then the tree.</b>
				</p>

				<p>
					<b>Tree</b> - The tree structure will check validity of each statement within the language and construct the intermediate code handed to SASM. It will be initially time consuming but once constructed is unlikely to require to many changes before the optimization stage ( This is where unnecessary operations will be removed and potential optimizations will most easily be seen ). <b class="subheading">The tree will be developed in tandem with the bison grammar. The initial tree structure will be taken from the prototype and the necessary changes will be made to strip away all of the derivation tree based execution and prepare it for a virtual machine.</b>

				</p>

				<p>
					<b>Glue</b> The bindings and wrapper that will allow the unwieldy Bison interface to exist and look nice within a C++11 environment. These will not be very time consuming and most can be adapted from the prototype. <b class="subheading">Starting from the second month work is expected to finish on the interface in a week.</b>
				</p>

				<b class="subheading" style="margin-left: 0;" >Work will begin from the second month. The estimates for each section will be highly unpredictable but it is likely that an initial version will be created within the first month.</b>

			</p>

			</p>

			</p>

			<p>

				<h3 class="roadmap-item-heading">Weekly iterations</h3> - From the beginning of the third month work should have progressed to the point where the language and virtual machine portions the project demands a similar amount of work. From this point on I will be proceeding with weekly sprints each focusing on a feature or a set of features from either the virtual machine or the language.

				<b class="subheading" style="margin-left: 0;" >Beginning from the third month of the first term and proceeding until the end of the first term.</b>

			</p>

			<hr/>

			<h2 class="heading" >Term Two</h2> <h3 class="subheading"> Interfacing & Refinement</h3>

			<p>For the second term I intend the focus of my work to be on optimization and bug fixing. Having a stable environment is integral for the development of a product and no sane developers would adopt a platform that was slow and crashed alot for a commercial product. Because of this need for stability most of the changes will not directly affect what a user sees but will instead be largely internal with a strong emphasis on improving what is already there rather than implementing new things. I also intend to develop a user friendly API allowing developers to easily interface native and Scribble code will be developed.However these objectives are low priority. allowing me some room to breath if the more difficult features tackled in the first term take more time than planned.</p>

			<hr/>

			<h3 class="roadmap-item-heading">The API</h3> - Once the VM is properly defined and implemented work can begin on an equivilent to the JNI or other native interfaces which will allow two way communication between the a developer in C++ and the functions executed on the Scribble virtual machine. <b class="subheading">Work will begin at the start of the second term. It should be completed in one month. A large amount of time is being left so that various methods of interfacing can be trailed.</b>

			<hr/>

			<h3 class="roadmap-item-heading">Feature freeze </h3> - From this point on bug fixing and speed will be the focus of development in order to get it into a polished state for the end of the project. New features will not be developed unless they are integral to the project. <b class="subheading">This will come into force at the end of the first month of the second term.</b>
			<hr/>

			<h3 class="roadmap-item-heading">Polishing reports and formal specifications</h3> - From this point on OpCodes, memory mangement etcetera will be set in stone and so each of the specifications and my final report draft will need going over to make sure that they are correct and to find any areas of ambiguity. I want to ensure that any client gets exactly what is described in the specification and that none of the behaviour of my code is ambiguous or contradicts the specification. Whilst it is unlikely that this will be entirely true as there are always bugs the issues should be as small as possible. <b class="subheading">This will be continuing from the third week of the second term until the end of the project.</b>

			<hr/>

			<h3 class="roadmap-item-heading">Optimization & Bugfinding</h3> - Scribble should be as difficult to crash as possible by the end of the project. To this end the remainder of the second term will be spent looking for issues which could cause the virtual machine to fail ungracefully ( It should never segmentation fault and always freeze after alerting the user to an issue and hopefully producing a detailed lot ) and issues in code generation causing the language to not work as intended. This is likely to be quite a lot of work as Scribble will have an extensive codebase by the end of the project. This is also being left tell last as if more time for features is required this can be overlooked<b class="subheading">This will be continuing from the third week of the second term until the end of the project.</b>


			</div>

		</div>

		<div class="panel">
			<h1 class="panel-header">Deliverables</h1>

			<div class="panel-content">

			<p>The first deliverable will be a report documenting the design process of the virtual machine. This document will list how the virtual machine has been designed and what potential limitations there could be from the choices made up to that point. This will be produced by the end of the third week.</p>

			<p>The second deliverable will be an initial specification for the virtual machine documenting it's inner workings and opcodes and other technical details. This will be produced by the end of the fourth week and will be accompanied by the virtual machine implementation. This is likely to only cover a minor subset of the final specification which will be designed iteratively later in parralel with the language.</p>

			<p>The third deliverable will be the intermediate language parser and specification completed half way through the second month of the first term.</p>

			<p>The fourth deliverable will be a document defining the language syntax, explaining how each feature of the language works and documenting why the I have made selected design choices. This will be produced by the end of the second month</p>

			<p>Reports will be produced in the middle of the third month and the end of of it documenting the changes made in the weekly feature developments.</p>

			<p>The next deliverable will be a set of API user documentation explaining all of the interfaces and classes as well as giving examples of how to incorperate Scribble into a project. This will be produced by the end of the second week of the second term.</p>

			<p>The final software deliverable will be a package which allows the user to compile and execute Scribble code with as few technical issues as possible. This will be delivered at the end of the project along with the project report.</p>

			</div>

		</div>


		<div class="panel">

			<h1 class="panel-header">Testing</h1>

			<div class="panel-content">
				Through this project I will be using C++ testing tools to maintain a set of tests to verify the functionality of the virtual machine, intermediate language and parser. The virtual machine tests will be constructed to the test that the virtual machine adheres to the specification by testing the virtual machine state after executing specific sets of bytecode. The tests for the intermediate language and Scribble itself will build upon these verifying that a piece of high level code gets converted into the correct intermediate and bytecode and that the expected result of any execution is correct.
			</div>

		</div>

		<div class="panel">
			<h1 class="panel-header">Reading</h1>

			<div class="panel-content">

				<p>During the summer I spent some time reading both about different parser technologies, this was when I decided to use Bison for the project ( Due to a wealth of online resources and extensive platform support ) and has proved a great help while preparing for my project. I will be continuing this reading until the start of the second term and will also be looking at technical documents for virtual machine such as the LUA VM and Java VM. This should help me in designing a virtual machine properly and avoiding some mistakes which could come back to bite me later.</p>

				<p>During the first term I will be reading the dragon book ( Compilers: Principles, Techniques, and Tools ) and also using the Elizabeth Scott's notes for the third year compilers course to aid in constructing a stable grammar and to bolster my knowledge in the more theoretical portions of the project.</p>

				<p>After the first term and the feature freeze I will not need the resources as much. However I will still be using reading on compilers and intermediate code generation as well as the virtual machine resources used earlier to improve the speed and stability of my language and to qualify decisions I've made when fleshing out their documentation in my final report</p>

				
			</div>

		</div>

	</body>
</html>

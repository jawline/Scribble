import("sys")

// Recursive fibs implementation
//
// n, The desired position in the sequence (Between 0 and infinity)
//
// The resulting value in the Fibonacci sequence
//
// This recursive fibs implementation recursively breaks down the
// fibonacci problem into a very simple algorithm. It is however considerably less
// memory efficient than its iterative counterparts

func Fibs(n : int) : int {
	
	if (n < 0) {
		sys.Write("N Should be a positive value\n")
		return 0
	}

	if (n = 0) {
		return 0
	}
	
	if (n = 1) {
		return 1
	}
	
	return Fibs(n - 1) + Fibs(n - 2)
}

func FibsIterative(n : int) : int {

	if n < 0 {
		sys.Write("Fibs is only valid on n > 0\n")
		return 0
	}
	
	if n = 0 {
		return 0
	}

	var l1 := 0
	var l2 := 1
	var c := 1

	for var i := 0; i < n; i++ {
		c := l1 + l2
		l2 := l1
		l1 := c
	}
	
	return c
}

func FibsSequence(n : int, r : array(int)) : void {

	if n < 0 {
		sys.Write("Fibs is only valid on n > 0\n")
		return
	}
	
	r[0] := 0
	
	if n != 0 {

		var l1 := 0
		var l2 := 1
		var c := 1
	
		for var i := 1; i < n; i++ {
			c := l1 + l2
			l2 := l1
			l1 := c
			r[i] := c
		}
		
	}
}

func Test() : bool {
	
	sys.Write("Fibonacci test. ")
	
	for var i := 0; i < 20; i++ {
		
		var sFibsResult := Fibs(i)
		var iFibsResult := FibsIterative(i)
		
		sys.Write(sys.String(Fibs(i)) + " ")
		
		if (sFibsResult != iFibsResult) {
			sys.Write("\nFibonacci test failed. iterative does not equal recursive result")
			return false
		}
		
	}
	
	sys.Write("\n")
	
	var fibs := [10]int
	FibsSequence(10, fibs)
	
	for i := 0; i < 10; i++ {
		sys.Write(sys.String(fibs[i]) + " ")
	}
	sys.Write("\n")
	
	return true
}
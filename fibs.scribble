import("sys")

// Recursive fibs implementation
//
// n, The desired position in the sequence (Between 0 and infinity)
//
// The resulting value in the Fibonacci sequence
//
// This recursive fibs implementation recursively breaks down the
// fibonacci problem into a very simple algorithm. It is however considerably less
// memory efficient than its iterative counterparts

func Fibs(n : int) : int {
	
	if (n < 0) {
		sys.Write("N Should be a positive value\n")
		return 0
	}

	if (n = 0) {
		return 0
	}
	
	if (n = 1) {
		return 1
	}
	
	return Fibs(n - 1) + Fibs(n - 2)
}

func FibsIterative(n : int) : int {

	if n < 0 {
		sys.Write("Fibs is only valid on n > 0\n")
		return 0
	}
	
	if n = 0 {
		return 0
	}

	auto l1 := 0
	auto l2 := 1
	auto c := 1

	for auto i := 0; i < n; i++ {
		c := l1 + l2
		l2 := l1
		l1 := c
	}
	
	return c
}

func Test() : bool {
	
	sys.Write("Fibonacci test. ")
	
	for auto i := 0; i < 20; i++ {
		
		auto sFibsResult := Fibs(i)
		auto iFibsResult := FibsIterative(i)
		
		sys.Write(sys.String(Fibs(i)) + " ")
		
		if (sFibsResult != iFibsResult) {
			sys.Write("\nFibonacci test failed. iterative does not equal recursive result")
			return false
		}
		
	}
	
	sys.Write("\n")
	
	return true
}
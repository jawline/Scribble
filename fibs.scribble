import("sys")

// Recursive fibs implementation
//
// n, The desired position in the sequence (Between 0 and infinity)
//
// The resulting value in the Fibonacci sequence
//
// This recursive fibs implementation recursively breaks down the
// fibonacci problem into a very simple algorithm. It is however considerably less
// memory efficient than its iterative counterparts

func Fibs(var n : int) : int {
	
	if (n < 0) {
		sys.Write("N Should be a positive value\n")
		return 0
	}

	if (n = 0) {
		return 0
	}
	
	if (n = 1) {
		return 1
	}
	
	return Fibs(n - 1) + Fibs(n - 2)
}

func FibsIterative(var n : int) : int {

	if n < 0 {
		sys.Write("Fibs is only valid on n > 0\n")
		return 0
	}
	
	if n = 0 {
		return 0
	}
	
	if n = 1 {
		return 1
	}

	auto l1 := 1
	auto l2 := 1
	auto c := 0

	for auto i := 0; i < n-1; i++ {
		c := l1 + l2
		l2 := l1
		l1 := c
	}
	
	return c
}

func Test() : bool {
	
	sys.Write("Fibonacci test. ")
	
	for auto i := 0; i < 20; i++ {
		sys.Write(sys.String(Fibs(i)) + " ")
	}
	
	sys.Write("\n")
	
	sys.Write("Iterative fibs test. ")
	
	for i := 0; i < 20; i++ {
		sys.Write(sys.String(FibsIterative(i)) + " ")
	}
	
	sys.Write("\n")
	
	return true
}